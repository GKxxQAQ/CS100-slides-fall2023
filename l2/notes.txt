虽然我们还没有正式地讲过“注释”，但我已经大量地在示例代码中使用。上课的时候可以简单提一嘴，之后会慢慢介绍如何正确使用注释。

P4 C 一般被认为是静态类型语言，但是 C99 起出现了一个特例，即 variable-length array (VLA)。这是一种数组，其长度是可以在运行期确定的：
```c
int n; scanf("%d", &n);
int a[n];
```
数组的类型包括两部分：其所存储的元素的类型，和它能存储的元素个数（长度）。所以一个 VLA 的类型也就是运行期确定的，这样的类型称为 variably-modified type。这会产生一些其它的影响，例如 `sizeof(a)` 是运行期才能求值的（一般的 `sizeof` 一定是在编译时求值的），以及 `typedef int vla_t[n];` 也会生成一些代码，因为它必须记录 `n` 的值。C11 起，编译器有权决定是否支持 VLA，而 C23 起，编译器就算不支持定义这样的数组，也必须支持使用这样的类型，详见[我的这篇博客](https://blog.csdn.net/qq_39677783/article/details/129219624?spm=1001.2014.3001.5501)。注意，VLA 从来没有加入 C++ 标准，我们 CS100 也不允许使用 VLA。

P5 这里的用词 "type-related error" 比较模糊，是故意的（所以加上了 "(usually)"）。比如给 `a = "hello"` 加个类型转换变成 `a = (int)"hello"`，程序就可能产生运行时错误，而这样的错误实际上也是和类型有关的。现阶段学生还什么都不知道，没法讲得太明确，只能先这样模糊一下。

P7 C99 之前，局部变量只能在块 (block) 的开头集中声明，不能在任意位置声明。C99 取消了这一规定，意在鼓励人们在即将使用这个变量的时候才去声明它，并且鼓励声明时立刻初始化它。如果声明的位置离真正的使用很远，我们怎么知道它应该被初始化为何值呢？

P14 需要简单解释一下这个程序，因为包含了 `while` 语句、`*=` 运算符和 `getchar()` 这些同学们没学过的东西。`getchar();` 放在这里是为了让输出停顿一下，待我们按下回车后再继续。注意，这并非 `getchar()` 的实际功能，我们只是这样简单地使用一下。

P15 绝大多数现代机器都认为一个字节是 8 位，但这并不是硬性规定。链接指向了 36-bit computing。我们课程可以假定一个字节是 8 位，不过我们应该不会这样考查。

P18 在 C23 和 C++20 以前，C/C++ 标准是允许任何带符号数表示形式的，因此 n 位的带符号数的保证有效范围是 [-2^{n-1}+1, 2^{n-1}-1]，例如 8 位的是 [-127, 127]，这是为了照顾像 one's complement 或者 sign-and-magnitude 这样的表示方式。但 two's complement 实在是太常用了，自 C23 和 C++20 起标准只允许用 two's complement 了。我们虽然是基于 C17 和 C++17，但也直接假定使用 two's complement。

P22 标准只规定了每一种整数类型至少多少位，以及它们之间的不等式链 (1 == sizeof(char) == sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long))。在绝大多数的 PC 上 `int` 都是 32 位，但的确有一些机器使用 16 位的 `int`，我很多年前曾在手机上安装过一个 C 编译器，它就显示 `int` 最大只有 32767。`long` 在我的 Windows 上是 32 位的，在我的 Ubuntu 上是 64 位。